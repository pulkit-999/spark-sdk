<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Sending payments - Breez SDK - Nodeless (Spark)</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../styles.css">
        <link rel="stylesheet" href="../theme/pagetoc.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Breez SDK - Nodeless (Spark)</h1>

                    <div class="right-buttons">
                        <a href="https://github.com/breez/spark-sdk" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/breez/spark-sdk/edit/main/crates/breez-sdk/docs/src/guide/send_payment.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="sending-payments"><a class="header" href="#sending-payments">Sending payments</a></h1>
<p>Once the SDK is initialized, you can directly begin sending payments. The send process takes two steps:</p>
<ol>
<li><a href="send_payment.html#preparing-payments">Preparing the Payment</a></li>
<li><a href="send_payment.html#sending-payments">Sending the Payment</a></li>
</ol>
<p>For sending payments via LNURL, see <a href="lnurl_pay.html">LNURL-Pay</a>.</p>
<h2 id="preparing-payments">
    <a class="header" href="#preparing-payments">Preparing Payments</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.BreezSdk.html#method.prepare_send_payment">API docs</a>
</h2>
<p>During the prepare step, the SDK ensures that the inputs are valid with respect to the payment request type,
and also returns the fees related to the payment so they can be confirmed.</p>
<p>The payment request field supports Lightning invoices, Bitcoin addresses, Spark addresses and Spark invoices.</p>
<div class="warning">
<h4 id="developer-note"><a class="header" href="#developer-note">Developer note</a></h4>
Payments can be sent without holding Bitcoin by converting on-the-fly as a step before sending a payment. See <a href="./token_conversion.html">Converting tokens</a> for more information.
</div>
<h2 id="lightning"><a class="header" href="#lightning">Lightning</a></h2>
<h4 id="bolt11-invoice"><a class="header" href="#bolt11-invoice">BOLT11 invoice</a></h4>
<p>For BOLT11 invoices the amount can be optionally set. The amount set in the request is only taken into account if it's an amountless invoice.</p>
<p>If the invoice also contains a Spark address, the payment can be sent directly via a Spark transfer instead. When this is the case, the prepare response includes the Spark transfer fee. Note that only one fee is paid: either the Lightning fee or the Spark transfer fee, depending on which payment method is ultimately used. See <a href="send_payment.html#lightning-1">Lightning</a> for how to select the payment method.</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">let payment_request = "&lt;bolt11 invoice&gt;".to_string();
// Optionally set the amount you wish the pay the receiver
let optional_pay_amount = Some(PayAmount::Bitcoin { amount_sats: 5_000 });

let prepare_response = sdk
    .prepare_send_payment(PrepareSendPaymentRequest {
        payment_request,
        pay_amount: optional_pay_amount,
        conversion_options: None,
    })
    .await?;

// If the fees are acceptable, continue to create the Send Payment
if let SendPaymentMethod::Bolt11Invoice {
    spark_transfer_fee_sats,
    lightning_fee_sats,
    ..
} = prepare_response.payment_method
{
    // Fees to pay via Lightning
    info!("Lightning Fees: {lightning_fee_sats} sats");
    // Or fees to pay (if available) via a Spark transfer
    info!("Spark Transfer Fees: {spark_transfer_fee_sats:?} sats");
}</code></pre>
</section>
<div slot="title">Swift</div>
<section>
<pre><code class="language-swift ignore">let paymentRequest = "&lt;bolt11 invoice&gt;"
// Optionally set the amount you wish to pay the receiver
let optionalPayAmount = PayAmount.bitcoin(amountSats: 5_000)

let prepareResponse = try await sdk.prepareSendPayment(
    request: PrepareSendPaymentRequest(
        paymentRequest: paymentRequest,
        payAmount: optionalPayAmount
    ))

if case let .bolt11Invoice(_, sparkTransferFeeSats, lightningFeeSats) = prepareResponse
    .paymentMethod
{
    // Fees to pay via Lightning
    print("Lightning Fees: \(lightningFeeSats) sats")
    // Or fees to pay (if available) via a Spark transfer
    if let sparkTransferFeeSats = sparkTransferFeeSats {
        print("Spark Transfer Fees: \(sparkTransferFeeSats) sats")
    }
}
</code></pre>
</section>
<div slot="title">Kotlin</div>
<section>
<pre><code class="language-kotlin ignore">val paymentRequest = "&lt;bolt11 invoice&gt;"
// Optionally set the amount you wish to pay the receiver
val optionalPayAmount = PayAmount.Bitcoin(amountSats = 5_000.toULong())

try {
    val req = PrepareSendPaymentRequest(
        paymentRequest,
        payAmount = optionalPayAmount,
    )
    val prepareResponse = sdk.prepareSendPayment(req)

    // If the fees are acceptable, continue to create the Send Payment
    val paymentMethod = prepareResponse.paymentMethod
    if (paymentMethod is SendPaymentMethod.Bolt11Invoice) {
        // Fees to pay via Lightning
        val lightningFeeSats = paymentMethod.lightningFeeSats
        // Or fees to pay (if available) via a Spark transfer
        val sparkTransferFeeSats = paymentMethod.sparkTransferFeeSats
        // Log.v("Breez", "Lightning Fees: ${lightningFeeSats} sats")
        // Log.v("Breez", "Spark Transfer Fees: ${sparkTransferFeeSats} sats")
    }
} catch (e: Exception) {
    // handle error
}
</code></pre>
</section>
<div slot="title">C#</div>
<section>
<pre><code class="language-csharp ignore">var paymentRequest = "&lt;bolt11 invoice&gt;";
// Optionally set the amount you wish to pay the receiver
var optionalPayAmount = new PayAmount.Bitcoin(5_000UL);

var request = new PrepareSendPaymentRequest(
    paymentRequest: paymentRequest,
    payAmount: optionalPayAmount
);
var prepareResponse = await sdk.PrepareSendPayment(request: request);

// If the fees are acceptable, continue to create the Send Payment
if (prepareResponse.paymentMethod is SendPaymentMethod.Bolt11Invoice bolt11Method)
{
    // Fees to pay via Lightning
    var lightningFeeSats = bolt11Method.lightningFeeSats;
    // Or fees to pay (if available) via a Spark transfer
    var sparkTransferFeeSats = bolt11Method.sparkTransferFeeSats;
    Console.WriteLine($"Lightning Fees: {lightningFeeSats} sats");
    Console.WriteLine($"Spark Transfer Fees: {sparkTransferFeeSats} sats");
}
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript ignore">const paymentRequest = '&lt;bolt11 invoice&gt;'
// Optionally set the amount you wish to pay the receiver
const optionalPayAmount: PayAmount = {
  type: 'bitcoin',
  amountSats: 5_000
}

const prepareResponse = await sdk.prepareSendPayment({
  paymentRequest,
  payAmount: optionalPayAmount
})

// If the fees are acceptable, continue to create the Send Payment
if (prepareResponse.paymentMethod.type === 'bolt11Invoice') {
  // Fees to pay via Lightning
  const lightningFeeSats = prepareResponse.paymentMethod.lightningFeeSats
  // Or fees to pay (if available) via a Spark transfer
  const sparkTransferFeeSats = prepareResponse.paymentMethod.sparkTransferFeeSats
  console.debug(`Lightning Fees: ${lightningFeeSats} sats`)
  console.debug(`Spark Transfer Fees: ${sparkTransferFeeSats} sats`)
}
</code></pre>
</section>
<div slot="title">React Native</div>
<section>
<pre><code class="language-typescript ignore">const paymentRequest = '&lt;bolt11 invoice&gt;'
// Optionally set the amount you wish to pay the receiver
const optionalPayAmount = new PayAmount.Bitcoin({ amountSats: BigInt(5_000) })

const prepareResponse = await sdk.prepareSendPayment({
  paymentRequest,
  payAmount: optionalPayAmount,
  conversionOptions: undefined
})

// If the fees are acceptable, continue to create the Send Payment
if (prepareResponse.paymentMethod?.tag === SendPaymentMethod_Tags.Bolt11Invoice) {
  // Fees to pay via Lightning
  const lightningFeeSats = prepareResponse.paymentMethod.inner.lightningFeeSats
  // Or fees to pay (if available) via a Spark transfer
  const sparkTransferFeeSats = prepareResponse.paymentMethod.inner.sparkTransferFeeSats
  console.debug(`Lightning Fees: ${lightningFeeSats} sats`)
  console.debug(`Spark Transfer Fees: ${sparkTransferFeeSats} sats`)
}
</code></pre>
</section>
<div slot="title">Flutter</div>
<section>
<pre><code class="language-dart ignore">String paymentRequest = "&lt;bolt11 invoice&gt;";
// Optionally set the amount you wish to pay the receiver
PayAmount optionalPayAmount = PayAmount.bitcoin(amountSats: BigInt.from(5000));

final request = PrepareSendPaymentRequest(
    paymentRequest: paymentRequest,
    payAmount: optionalPayAmount);
final response = await sdk.prepareSendPayment(request: request);

// If the fees are acceptable, continue to create the Send Payment
final paymentMethod = response.paymentMethod;
if (paymentMethod is SendPaymentMethod_Bolt11Invoice) {
  // Fees to pay via Lightning
  final lightningFeeSats = paymentMethod.lightningFeeSats;
  // Or fees to pay (if available) via a Spark transfer
  final sparkTransferFeeSats = paymentMethod.sparkTransferFeeSats;
  print("Lightning Fees: $lightningFeeSats sats");
  print("Spark Transfer Fees: $sparkTransferFeeSats sats");
}
</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python ignore">payment_request = "&lt;bolt11 invoice&gt;"
# Optionally set the amount you wish to pay the receiver
optional_pay_amount = PayAmount.BITCOIN(amount_sats=5_000)
try:
    request = PrepareSendPaymentRequest(
        payment_request=payment_request,
        pay_amount=optional_pay_amount,
    )
    prepare_response = await sdk.prepare_send_payment(request=request)

    # If the fees are acceptable, continue to create the Send Payment
    if isinstance(
        prepare_response.payment_method, SendPaymentMethod.BOLT11_INVOICE
    ):
        # Fees to pay via Lightning
        lightning_fee_sats = prepare_response.payment_method.lightning_fee_sats
        # Or fees to pay (if available) via a Spark transfer
        spark_transfer_fee_sats = (
            prepare_response.payment_method.spark_transfer_fee_sats
        )
        logging.debug(f"Lightning Fees: {lightning_fee_sats} sats")
        logging.debug(f"Spark Transfer Fees: {spark_transfer_fee_sats} sats")
except Exception as error:
    logging.error(error)
    raise
</code></pre>
</section>
<div slot="title">Go</div>
<section>
<pre><code class="language-go ignore">paymentRequest := "&lt;bolt11 invoice&gt;"
// Optionally set the amount you wish to pay the receiver
var optionalPayAmount breez_sdk_spark.PayAmount = breez_sdk_spark.PayAmountBitcoin{
	AmountSats: 5_000,
}

request := breez_sdk_spark.PrepareSendPaymentRequest{
	PaymentRequest: paymentRequest,
	PayAmount:      &amp;optionalPayAmount,
}
response, err := sdk.PrepareSendPayment(request)

if err != nil {
	var sdkErr *breez_sdk_spark.SdkError
	if errors.As(err, &amp;sdkErr) {
		// Handle SdkError - can inspect specific variants if needed
		// e.g., switch on sdkErr variant for InsufficientFunds, NetworkError, etc.
	}
	return nil, err
}

// If the fees are acceptable, continue to create the Send Payment
switch paymentMethod := response.PaymentMethod.(type) {
case breez_sdk_spark.SendPaymentMethodBolt11Invoice:
	// Fees to pay via Lightning
	lightningFeeSats := paymentMethod.LightningFeeSats
	// Or fees to pay (if available) via a Spark transfer
	sparkTransferFeeSats := paymentMethod.SparkTransferFeeSats
	log.Printf("Lightning Fees: %v sats", lightningFeeSats)
	log.Printf("Spark Transfer Fees: %v sats", sparkTransferFeeSats)
}
</code></pre>
</section>
</custom-tabs>
<h2 id="bitcoin"><a class="header" href="#bitcoin">Bitcoin</a></h2>
<p>For Bitcoin addresses, the amount must be set in the request. The prepare response includes fee quotes for three payment speeds: Slow, Medium, and Fast.</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">let payment_request = "&lt;bitcoin address&gt;".to_string();
// Set the amount you wish to pay the receiver
let pay_amount = Some(PayAmount::Bitcoin { amount_sats: 50_000 });

let prepare_response = sdk
    .prepare_send_payment(PrepareSendPaymentRequest {
        payment_request,
        pay_amount,
        conversion_options: None,
    })
    .await?;

// Review the fee quote for each confirmation speed
if let SendPaymentMethod::BitcoinAddress { fee_quote, .. } = &amp;prepare_response.payment_method {
    info!("Slow fee: {} sats", fee_quote.speed_slow.total_fee_sat());
    info!("Medium fee: {} sats", fee_quote.speed_medium.total_fee_sat());
    info!("Fast fee: {} sats", fee_quote.speed_fast.total_fee_sat());
}</code></pre>
</section>
<div slot="title">Swift</div>
<section>
<pre><code class="language-swift ignore">let paymentRequest = "&lt;bitcoin address&gt;"
// Set the amount you wish to pay the receiver
let payAmount = PayAmount.bitcoin(amountSats: 50_000)

let prepareResponse = try await sdk.prepareSendPayment(
    request: PrepareSendPaymentRequest(
        paymentRequest: paymentRequest,
        payAmount: payAmount
    ))

// Review the fee quote for each confirmation speed
if case let .bitcoinAddress(address: _, feeQuote: feeQuote) = prepareResponse.paymentMethod {
    let slowFeeSats = feeQuote.speedSlow.userFeeSat + feeQuote.speedSlow.l1BroadcastFeeSat
    let mediumFeeSats = feeQuote.speedMedium.userFeeSat + feeQuote.speedMedium.l1BroadcastFeeSat
    let fastFeeSats = feeQuote.speedFast.userFeeSat + feeQuote.speedFast.l1BroadcastFeeSat
    print("Slow fee: \(slowFeeSats) sats")
    print("Medium fee: \(mediumFeeSats) sats")
    print("Fast fee: \(fastFeeSats) sats")
}
</code></pre>
</section>
<div slot="title">Kotlin</div>
<section>
<pre><code class="language-kotlin ignore">val paymentRequest = "&lt;bitcoin address&gt;"
// Set the amount you wish to pay the receiver
val payAmount = PayAmount.Bitcoin(amountSats = 50_000.toULong())

try {
    val req = PrepareSendPaymentRequest(
        paymentRequest,
        payAmount,
    )
    val prepareResponse = sdk.prepareSendPayment(req)

    // Review the fee quote for each confirmation speed
    val paymentMethod = prepareResponse.paymentMethod
    if (paymentMethod is SendPaymentMethod.BitcoinAddress) {
        val feeQuote = paymentMethod.feeQuote
        val slowFeeSats = feeQuote.speedSlow.userFeeSat + feeQuote.speedSlow.l1BroadcastFeeSat
        val mediumFeeSats = feeQuote.speedMedium.userFeeSat + feeQuote.speedMedium.l1BroadcastFeeSat
        val fastFeeSats = feeQuote.speedFast.userFeeSat + feeQuote.speedFast.l1BroadcastFeeSat
        // Log.v("Breez", "Slow fee: $slowFeeSats sats")
        // Log.v("Breez", "Medium fee: $mediumFeeSats sats")
        // Log.v("Breez", "Fast fee: $fastFeeSats sats")
    }
} catch (e: Exception) {
    // handle error
}
</code></pre>
</section>
<div slot="title">C#</div>
<section>
<pre><code class="language-csharp ignore">var paymentRequest = "&lt;bitcoin address&gt;";
// Set the amount you wish to pay the receiver
var payAmount = new PayAmount.Bitcoin(50_000UL);

var request = new PrepareSendPaymentRequest(
    paymentRequest: paymentRequest,
    payAmount: payAmount
);
var prepareResponse = await sdk.PrepareSendPayment(request: request);

// Review the fee quote for each confirmation speed
if (prepareResponse.paymentMethod is SendPaymentMethod.BitcoinAddress bitcoinMethod)
{
    var feeQuote = bitcoinMethod.feeQuote;
    var slowFeeSats = feeQuote.speedSlow.userFeeSat + feeQuote.speedSlow.l1BroadcastFeeSat;
    var mediumFeeSats = feeQuote.speedMedium.userFeeSat + feeQuote.speedMedium.l1BroadcastFeeSat;
    var fastFeeSats = feeQuote.speedFast.userFeeSat + feeQuote.speedFast.l1BroadcastFeeSat;
    Console.WriteLine($"Slow fee: {slowFeeSats} sats");
    Console.WriteLine($"Medium fee: {mediumFeeSats} sats");
    Console.WriteLine($"Fast fee: {fastFeeSats} sats");
}
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript ignore">const paymentRequest = '&lt;bitcoin address&gt;'
// Set the amount you wish to pay the receiver
const payAmount: PayAmount = {
  type: 'bitcoin',
  amountSats: 50_000
}

const prepareResponse = await sdk.prepareSendPayment({
  paymentRequest,
  payAmount
})

// Review the fee quote for each confirmation speed
if (prepareResponse.paymentMethod.type === 'bitcoinAddress') {
  const feeQuote = prepareResponse.paymentMethod.feeQuote
  const slowFeeSats = feeQuote.speedSlow.userFeeSat + feeQuote.speedSlow.l1BroadcastFeeSat
  const mediumFeeSats = feeQuote.speedMedium.userFeeSat + feeQuote.speedMedium.l1BroadcastFeeSat
  const fastFeeSats = feeQuote.speedFast.userFeeSat + feeQuote.speedFast.l1BroadcastFeeSat
  console.debug(`Slow fee: ${slowFeeSats} sats`)
  console.debug(`Medium fee: ${mediumFeeSats} sats`)
  console.debug(`Fast fee: ${fastFeeSats} sats`)
}
</code></pre>
</section>
<div slot="title">React Native</div>
<section>
<pre><code class="language-typescript ignore">const paymentRequest = '&lt;bitcoin address&gt;'
// Set the amount you wish to pay the receiver
const payAmount = new PayAmount.Bitcoin({ amountSats: BigInt(50_000) })

const prepareResponse = await sdk.prepareSendPayment({
  paymentRequest,
  payAmount,
  conversionOptions: undefined
})

// Review the fee quote for each confirmation speed
if (prepareResponse.paymentMethod?.tag === SendPaymentMethod_Tags.BitcoinAddress) {
  const feeQuote = prepareResponse.paymentMethod.inner.feeQuote
  const slowFeeSats = feeQuote.speedSlow.userFeeSat + feeQuote.speedSlow.l1BroadcastFeeSat
  const mediumFeeSats = feeQuote.speedMedium.userFeeSat + feeQuote.speedMedium.l1BroadcastFeeSat
  const fastFeeSats = feeQuote.speedFast.userFeeSat + feeQuote.speedFast.l1BroadcastFeeSat
  console.debug(`Slow fee: ${slowFeeSats} sats`)
  console.debug(`Medium fee: ${mediumFeeSats} sats`)
  console.debug(`Fast fee: ${fastFeeSats} sats`)
}
</code></pre>
</section>
<div slot="title">Flutter</div>
<section>
<pre><code class="language-dart ignore">String paymentRequest = "&lt;bitcoin address&gt;";
// Set the amount you wish to pay the receiver
PayAmount payAmount = PayAmount.bitcoin(amountSats: BigInt.from(50000));

final request = PrepareSendPaymentRequest(
    paymentRequest: paymentRequest,
    payAmount: payAmount);
final response = await sdk.prepareSendPayment(request: request);

// Review the fee quote for each confirmation speed
final paymentMethod = response.paymentMethod;
if (paymentMethod is SendPaymentMethod_BitcoinAddress) {
  final feeQuote = paymentMethod.feeQuote;
  final slowFeeSats = feeQuote.speedSlow.userFeeSat + feeQuote.speedSlow.l1BroadcastFeeSat;
  final mediumFeeSats = feeQuote.speedMedium.userFeeSat + feeQuote.speedMedium.l1BroadcastFeeSat;
  final fastFeeSats = feeQuote.speedFast.userFeeSat + feeQuote.speedFast.l1BroadcastFeeSat;
  print("Slow fee: $slowFeeSats sats");
  print("Medium fee: $mediumFeeSats sats");
  print("Fast fee: $fastFeeSats sats");
}
</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python ignore">payment_request = "&lt;bitcoin address&gt;"
# Set the amount you wish to pay the receiver
pay_amount = PayAmount.BITCOIN(amount_sats=50_000)
try:
    request = PrepareSendPaymentRequest(
        payment_request=payment_request,
        pay_amount=pay_amount,
    )
    prepare_response = await sdk.prepare_send_payment(request=request)

    # Review the fee quote for each confirmation speed
    if isinstance(
        prepare_response.payment_method, SendPaymentMethod.BITCOIN_ADDRESS
    ):
        fee_quote = prepare_response.payment_method.fee_quote
        slow_fee_sats = (
            fee_quote.speed_slow.user_fee_sat
            + fee_quote.speed_slow.l1_broadcast_fee_sat
        )
        medium_fee_sats = (
            fee_quote.speed_medium.user_fee_sat
            + fee_quote.speed_medium.l1_broadcast_fee_sat
        )
        fast_fee_sats = (
            fee_quote.speed_fast.user_fee_sat
            + fee_quote.speed_fast.l1_broadcast_fee_sat
        )
        logging.debug(f"Slow fee: {slow_fee_sats} sats")
        logging.debug(f"Medium fee: {medium_fee_sats} sats")
        logging.debug(f"Fast fee: {fast_fee_sats} sats")
except Exception as error:
    logging.error(error)
    raise
</code></pre>
</section>
<div slot="title">Go</div>
<section>
<pre><code class="language-go ignore">paymentRequest := "&lt;bitcoin address&gt;"
// Set the amount you wish to pay the receiver
var payAmount breez_sdk_spark.PayAmount = breez_sdk_spark.PayAmountBitcoin{
	AmountSats: 50_000,
}

request := breez_sdk_spark.PrepareSendPaymentRequest{
	PaymentRequest: paymentRequest,
	PayAmount:      &amp;payAmount,
}
response, err := sdk.PrepareSendPayment(request)

if err != nil {
	var sdkErr *breez_sdk_spark.SdkError
	if errors.As(err, &amp;sdkErr) {
		// Handle SdkError - can inspect specific variants if needed
		// e.g., switch on sdkErr variant for InsufficientFunds, NetworkError, etc.
	}
	return nil, err
}

// Review the fee quote for each confirmation speed
switch paymentMethod := response.PaymentMethod.(type) {
case breez_sdk_spark.SendPaymentMethodBitcoinAddress:
	feeQuote := paymentMethod.FeeQuote
	slowFeeSats := feeQuote.SpeedSlow.UserFeeSat + feeQuote.SpeedSlow.L1BroadcastFeeSat
	mediumFeeSats := feeQuote.SpeedMedium.UserFeeSat + feeQuote.SpeedMedium.L1BroadcastFeeSat
	fastFeeSats := feeQuote.SpeedFast.UserFeeSat + feeQuote.SpeedFast.L1BroadcastFeeSat
	log.Printf("Slow fee: %v sats", slowFeeSats)
	log.Printf("Medium fee: %v sats", mediumFeeSats)
	log.Printf("Fast fee: %v sats", fastFeeSats)
}
</code></pre>
</section>
</custom-tabs>
<h2 id="spark"><a class="header" href="#spark">Spark</a></h2>
<h4 id="spark-address"><a class="header" href="#spark-address">Spark address</a></h4>
<p>For Spark addresses, the amount must be set in the request. Sending to a Spark address uses a direct Spark transfer.</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">let payment_request = "&lt;spark address&gt;".to_string();
// Set the amount you wish to pay the receiver
let pay_amount = Some(PayAmount::Bitcoin { amount_sats: 50_000 });

let prepare_response = sdk
    .prepare_send_payment(PrepareSendPaymentRequest {
        payment_request,
        pay_amount,
        conversion_options: None,
    })
    .await?;

// If the fees are acceptable, continue to create the Send Payment
if let SendPaymentMethod::SparkAddress { fee, .. } = prepare_response.payment_method {
    info!("Fees: {} sats", fee);
}</code></pre>
</section>
<div slot="title">Swift</div>
<section>
<pre><code class="language-swift ignore">let paymentRequest = "&lt;spark address&gt;"
// Set the amount you wish to pay the receiver
let payAmount = PayAmount.bitcoin(amountSats: 50_000)

let prepareResponse = try await sdk.prepareSendPayment(
    request: PrepareSendPaymentRequest(
        paymentRequest: paymentRequest,
        payAmount: payAmount
    ))

if case let .sparkAddress(_, feeSats, _) = prepareResponse.paymentMethod {
    print("Fees: \(feeSats) sats")
}
</code></pre>
</section>
<div slot="title">Kotlin</div>
<section>
<pre><code class="language-kotlin ignore">val paymentRequest = "&lt;spark address&gt;"
// Set the amount you wish to pay the receiver
val payAmount = PayAmount.Bitcoin(amountSats = 50_000.toULong())

try {
    val req = PrepareSendPaymentRequest(
        paymentRequest,
        payAmount,
    )
    val prepareResponse = sdk.prepareSendPayment(req)

    // If the fees are acceptable, continue to create the Send Payment
    val paymentMethod = prepareResponse.paymentMethod
    if (paymentMethod is SendPaymentMethod.SparkAddress) {
        val feeSats = paymentMethod.fee
        // Log.v("Breez", "Fees: ${feeSats} sats")
    }
} catch (e: Exception) {
    // handle error
}
</code></pre>
</section>
<div slot="title">C#</div>
<section>
<pre><code class="language-csharp ignore">var paymentRequest = "&lt;spark address&gt;";
// Set the amount you wish to pay the receiver
var payAmount = new PayAmount.Bitcoin(50_000UL);

var request = new PrepareSendPaymentRequest(
    paymentRequest: paymentRequest,
    payAmount: payAmount
);
var prepareResponse = await sdk.PrepareSendPayment(request: request);

// If the fees are acceptable, continue to create the Send Payment
if (prepareResponse.paymentMethod is SendPaymentMethod.SparkAddress sparkMethod)
{
    var fee = sparkMethod.fee;
    Console.WriteLine($"Fees: {fee} sats");
}
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript ignore">const paymentRequest = '&lt;spark address&gt;'
// Set the amount you wish to pay the receiver
const payAmount: PayAmount = {
  type: 'bitcoin',
  amountSats: 50_000
}

const prepareResponse = await sdk.prepareSendPayment({
  paymentRequest,
  payAmount
})

// If the fees are acceptable, continue to create the Send Payment
if (prepareResponse.paymentMethod.type === 'sparkAddress') {
  const feeSats = prepareResponse.paymentMethod.fee
  console.debug(`Fees: ${feeSats} sats`)
}
</code></pre>
</section>
<div slot="title">React Native</div>
<section>
<pre><code class="language-typescript ignore">const paymentRequest = '&lt;spark address&gt;'
// Set the amount you wish to pay the receiver
const payAmount = new PayAmount.Bitcoin({ amountSats: BigInt(50_000) })

const prepareResponse = await sdk.prepareSendPayment({
  paymentRequest,
  payAmount,
  conversionOptions: undefined
})

// If the fees are acceptable, continue to create the Send Payment
if (prepareResponse.paymentMethod?.tag === SendPaymentMethod_Tags.SparkAddress) {
  const feeSats = prepareResponse.paymentMethod.inner.fee
  console.debug(`Fees: ${feeSats} sats`)
}
</code></pre>
</section>
<div slot="title">Flutter</div>
<section>
<pre><code class="language-dart ignore">String paymentRequest = "&lt;spark address&gt;";
// Set the amount you wish to pay the receiver
PayAmount payAmount = PayAmount.bitcoin(amountSats: BigInt.from(50000));

final request = PrepareSendPaymentRequest(
    paymentRequest: paymentRequest,
    payAmount: payAmount);
final response = await sdk.prepareSendPayment(request: request);

// If the fees are acceptable, continue to create the Send Payment
final paymentMethod = response.paymentMethod;
if (paymentMethod is SendPaymentMethod_SparkAddress) {
  final feeSats = paymentMethod.fee;
  print("Fees: $feeSats sats");
}
</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python ignore">payment_request = "&lt;spark address&gt;"
# Set the amount you wish to pay the receiver
pay_amount = PayAmount.BITCOIN(amount_sats=50_000)
try:
    request = PrepareSendPaymentRequest(
        payment_request=payment_request,
        pay_amount=pay_amount,
    )
    prepare_response = await sdk.prepare_send_payment(request=request)

    # If the fees are acceptable, continue to create the Send Payment
    if isinstance(prepare_response.payment_method, SendPaymentMethod.SPARK_ADDRESS):
        fee = prepare_response.payment_method.fee
        logging.debug(f"Fees: {fee} sats")
except Exception as error:
    logging.error(error)
    raise
</code></pre>
</section>
<div slot="title">Go</div>
<section>
<pre><code class="language-go ignore">paymentRequest := "&lt;spark address&gt;"
// Set the amount you wish to pay the receiver
var payAmount breez_sdk_spark.PayAmount = breez_sdk_spark.PayAmountBitcoin{
	AmountSats: 50_000,
}

request := breez_sdk_spark.PrepareSendPaymentRequest{
	PaymentRequest: paymentRequest,
	PayAmount:      &amp;payAmount,
}
response, err := sdk.PrepareSendPayment(request)

if err != nil {
	var sdkErr *breez_sdk_spark.SdkError
	if errors.As(err, &amp;sdkErr) {
		// Handle SdkError - can inspect specific variants if needed
		// e.g., switch on sdkErr variant for InsufficientFunds, NetworkError, etc.
	}
	return nil, err
}

// If the fees are acceptable, continue to create the Send Payment
switch paymentMethod := response.PaymentMethod.(type) {
case breez_sdk_spark.SendPaymentMethodSparkAddress:
	feeSats := paymentMethod.Fee
	log.Printf("Fees: %v sats", feeSats)
}
</code></pre>
</section>
</custom-tabs>
<h4 id="spark-invoice"><a class="header" href="#spark-invoice">Spark invoice</a></h4>
<p>For Spark invoices, the amount can be optionally set. It is only required if the invoice doesn't specify an amount. If the invoice specifies an amount, providing a different amount is not supported.</p>
<div class="warning">
<h4 id="developer-note-1"><a class="header" href="#developer-note-1">Developer note</a></h4>
Spark invoices may require a token (non-Bitcoin) as the payment asset. To determine the requirements of a Spark invoice and any restrictions it may impose, see the <a href="./parse.html">Parsing inputs</a> page. To learn more about tokens, see the <a href="./tokens.html">Handling tokens</a> page.
</div>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">let payment_request = "&lt;spark invoice&gt;".to_string();
// Optionally set the amount you wish to pay the receiver
let optional_pay_amount = Some(PayAmount::Bitcoin { amount_sats: 50_000 });

let prepare_response = sdk
    .prepare_send_payment(PrepareSendPaymentRequest {
        payment_request,
        pay_amount: optional_pay_amount,
        conversion_options: None,
    })
    .await?;

// If the fees are acceptable, continue to create the Send Payment
if let SendPaymentMethod::SparkInvoice { fee, .. } = prepare_response.payment_method {
    info!("Fees: {} sats", fee);
}</code></pre>
</section>
<div slot="title">Swift</div>
<section>
<pre><code class="language-swift ignore">let paymentRequest = "&lt;spark invoice&gt;"
// Optionally set the amount you wish to pay the receiver
let optionalPayAmount = PayAmount.bitcoin(amountSats: 50_000)

let prepareResponse = try await sdk.prepareSendPayment(
    request: PrepareSendPaymentRequest(
        paymentRequest: paymentRequest,
        payAmount: optionalPayAmount
    ))

if case let .sparkInvoice(_, feeSats, _) = prepareResponse.paymentMethod {
    print("Fees: \(feeSats) sats")
}
</code></pre>
</section>
<div slot="title">Kotlin</div>
<section>
<pre><code class="language-kotlin ignore">val paymentRequest = "&lt;spark invoice&gt;"
// Optionally set the amount you wish to pay the receiver
val optionalPayAmount = PayAmount.Bitcoin(amountSats = 50_000.toULong())

try {
    val req = PrepareSendPaymentRequest(
        paymentRequest,
        optionalPayAmount,
    )
    val prepareResponse = sdk.prepareSendPayment(req)

    // If the fees are acceptable, continue to create the Send Payment
    val paymentMethod = prepareResponse.paymentMethod
    if (paymentMethod is SendPaymentMethod.SparkInvoice) {
        val feeSats = paymentMethod.fee
        // Log.v("Breez", "Fees: ${feeSats} sats")
    }
} catch (e: Exception) {
    // handle error
}
</code></pre>
</section>
<div slot="title">C#</div>
<section>
<pre><code class="language-csharp ignore">var paymentRequest = "&lt;spark invoice&gt;";
// Optionally set the amount you wish to pay the receiver
var optionalPayAmount = new PayAmount.Bitcoin(50_000UL);

var request = new PrepareSendPaymentRequest(
    paymentRequest: paymentRequest,
    payAmount: optionalPayAmount
);
var prepareResponse = await sdk.PrepareSendPayment(request: request);

// If the fees are acceptable, continue to create the Send Payment
if (prepareResponse.paymentMethod is SendPaymentMethod.SparkInvoice sparkInvoiceMethod)
{
    var fee = sparkInvoiceMethod.fee;
    Console.WriteLine($"Fees: {fee} sats");
}
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript ignore">const paymentRequest = '&lt;spark invoice&gt;'
// Optionally set the amount you wish to pay the receiver
const optionalPayAmount: PayAmount = {
  type: 'bitcoin',
  amountSats: 50_000
}

const prepareResponse = await sdk.prepareSendPayment({
  paymentRequest,
  payAmount: optionalPayAmount
})

// If the fees are acceptable, continue to create the Send Payment
if (prepareResponse.paymentMethod.type === 'sparkInvoice') {
  const feeSats = prepareResponse.paymentMethod.fee
  console.debug(`Fees: ${feeSats} sats`)
}
</code></pre>
</section>
<div slot="title">React Native</div>
<section>
<pre><code class="language-typescript ignore">const paymentRequest = '&lt;spark invoice&gt;'
// Optionally set the amount you wish to pay the receiver
const optionalPayAmount = new PayAmount.Bitcoin({ amountSats: BigInt(50_000) })

const prepareResponse = await sdk.prepareSendPayment({
  paymentRequest,
  payAmount: optionalPayAmount,
  conversionOptions: undefined
})

// If the fees are acceptable, continue to create the Send Payment
if (prepareResponse.paymentMethod?.tag === SendPaymentMethod_Tags.SparkInvoice) {
  const feeSats = prepareResponse.paymentMethod.inner.fee
  console.debug(`Fees: ${feeSats} sats`)
}
</code></pre>
</section>
<div slot="title">Flutter</div>
<section>
<pre><code class="language-dart ignore">String paymentRequest = "&lt;spark invoice&gt;";
// Optionally set the amount you wish to pay the receiver
PayAmount optionalPayAmount = PayAmount.bitcoin(amountSats: BigInt.from(50000));

final request = PrepareSendPaymentRequest(
    paymentRequest: paymentRequest,
    payAmount: optionalPayAmount);
final response = await sdk.prepareSendPayment(request: request);

// If the fees are acceptable, continue to create the Send Payment
final paymentMethod = response.paymentMethod;
if (paymentMethod is SendPaymentMethod_SparkInvoice) {
  final feeSats = paymentMethod.fee;
  print("Fees: $feeSats sats");
}
</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python ignore">payment_request = "&lt;spark invoice&gt;"
# Optionally set the amount you wish to pay the receiver
optional_pay_amount = PayAmount.BITCOIN(amount_sats=50_000)
try:
    request = PrepareSendPaymentRequest(
        payment_request=payment_request,
        pay_amount=optional_pay_amount,
    )
    prepare_response = await sdk.prepare_send_payment(request=request)

    # If the fees are acceptable, continue to create the Send Payment
    if isinstance(prepare_response.payment_method, SendPaymentMethod.SPARK_INVOICE):
        fee = prepare_response.payment_method.fee
        logging.debug(f"Fees: {fee} sats")
except Exception as error:
    logging.error(error)
    raise
</code></pre>
</section>
<div slot="title">Go</div>
<section>
<pre><code class="language-go ignore">paymentRequest := "&lt;spark invoice&gt;"
// Optionally set the amount you wish to pay the receiver
var optionalPayAmount breez_sdk_spark.PayAmount = breez_sdk_spark.PayAmountBitcoin{
	AmountSats: 50_000,
}

request := breez_sdk_spark.PrepareSendPaymentRequest{
	PaymentRequest: paymentRequest,
	PayAmount:      &amp;optionalPayAmount,
}
response, err := sdk.PrepareSendPayment(request)

if err != nil {
	var sdkErr *breez_sdk_spark.SdkError
	if errors.As(err, &amp;sdkErr) {
		// Handle SdkError - can inspect specific variants if needed
		// e.g., switch on sdkErr variant for InsufficientFunds, NetworkError, etc.
	}
	return nil, err
}

// If the fees are acceptable, continue to create the Send Payment
switch paymentMethod := response.PaymentMethod.(type) {
case breez_sdk_spark.SendPaymentMethodSparkInvoice:
	feeSats := paymentMethod.Fee
	log.Printf("Fees: %v sats", feeSats)
}
</code></pre>
</section>
</custom-tabs>
<h2 id="draining"><a class="header" href="#draining">Draining</a></h2>
<p>To send the entire available balance minus fees, specify the drain option for the payment amount. Draining is supported for Bitcoin addresses, Spark addresses, and amountless Spark invoices. Lightning invoices and Spark invoices with an amount do not support draining.</p>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">// Use PayAmount::Drain to send all available funds
let payment_request = "&lt;payment request&gt;".to_string();
let pay_amount = Some(PayAmount::Drain);

let prepare_response = sdk
    .prepare_send_payment(PrepareSendPaymentRequest {
        payment_request,
        pay_amount,
        conversion_options: None,
    })
    .await?;

// The response contains PayAmount::Drain to indicate this is a drain operation
info!("Pay amount: {:?}", prepare_response.pay_amount);</code></pre>
</section>
<div slot="title">Swift</div>
<section>
<pre><code class="language-swift ignore">// Use PayAmount.drain to send all available funds
let paymentRequest = "&lt;payment request&gt;"
let payAmount = PayAmount.drain

let prepareResponse = try await sdk.prepareSendPayment(
    request: PrepareSendPaymentRequest(
        paymentRequest: paymentRequest,
        payAmount: payAmount
    ))

// The response contains PayAmount.drain to indicate this is a drain operation
print("Pay amount: \(prepareResponse.payAmount)")
</code></pre>
</section>
<div slot="title">Kotlin</div>
<section>
<pre><code class="language-kotlin ignore">// Use PayAmount.Drain to send all available funds
val paymentRequest = "&lt;payment request&gt;"
val payAmount = PayAmount.Drain

try {
    val req = PrepareSendPaymentRequest(
        paymentRequest,
        payAmount,
    )
    val prepareResponse = sdk.prepareSendPayment(req)

    // The response contains PayAmount.Drain to indicate this is a drain operation
    // Log.v("Breez", "Pay amount: ${prepareResponse.payAmount}")
} catch (e: Exception) {
    // handle error
}
</code></pre>
</section>
<div slot="title">C#</div>
<section>
<pre><code class="language-csharp ignore">// Use PayAmount.Drain to send all available funds
var paymentRequest = "&lt;payment request&gt;";
var payAmount = new PayAmount.Drain();

var request = new PrepareSendPaymentRequest(
    paymentRequest: paymentRequest,
    payAmount: payAmount
);
var prepareResponse = await sdk.PrepareSendPayment(request: request);

// The response contains PayAmount.Drain to indicate this is a drain operation
Console.WriteLine($"Pay amount: {prepareResponse.payAmount}");
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript ignore">// Use PayAmount Drain to send all available funds
const paymentRequest = '&lt;payment request&gt;'
const payAmount: PayAmount = { type: 'drain' }

const prepareResponse = await sdk.prepareSendPayment({
  paymentRequest,
  payAmount
})

// The response contains PayAmount Drain to indicate this is a drain operation
console.log(`Pay amount: ${JSON.stringify(prepareResponse.payAmount)}`)
</code></pre>
</section>
<div slot="title">React Native</div>
<section>
<pre><code class="language-typescript ignore">// Use PayAmount.Drain to send all available funds
const paymentRequest = '&lt;payment request&gt;'
const payAmount = new PayAmount.Drain()

const prepareResponse = await sdk.prepareSendPayment({
  paymentRequest,
  payAmount,
  conversionOptions: undefined
})

// The response contains PayAmount.Drain to indicate this is a drain operation
console.log(`Pay amount: ${JSON.stringify(prepareResponse.payAmount)}`)
</code></pre>
</section>
<div slot="title">Flutter</div>
<section>
<pre><code class="language-dart ignore">// Use PayAmount.drain() to send all available funds
String paymentRequest = "&lt;payment request&gt;";
PayAmount payAmount = PayAmount.drain();

final request = PrepareSendPaymentRequest(
    paymentRequest: paymentRequest,
    payAmount: payAmount);
final response = await sdk.prepareSendPayment(request: request);

// The response contains PayAmount.drain() to indicate this is a drain operation
print("Pay amount: ${response.payAmount}");
</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python ignore"># Use PayAmount.DRAIN to send all available funds
payment_request = "&lt;payment request&gt;"
pay_amount = PayAmount.DRAIN()
try:
    request = PrepareSendPaymentRequest(
        payment_request=payment_request,
        pay_amount=pay_amount,
    )
    prepare_response = await sdk.prepare_send_payment(request=request)

    # The response contains PayAmount.DRAIN to indicate this is a drain operation
    logging.debug(f"Pay amount: {prepare_response.pay_amount}")
except Exception as error:
    logging.error(error)
    raise
</code></pre>
</section>
<div slot="title">Go</div>
<section>
<pre><code class="language-go ignore">// Use PayAmountDrain to send all available funds
paymentRequest := "&lt;payment request&gt;"
var payAmount breez_sdk_spark.PayAmount = breez_sdk_spark.PayAmountDrain{}

request := breez_sdk_spark.PrepareSendPaymentRequest{
	PaymentRequest: paymentRequest,
	PayAmount:      &amp;payAmount,
}
response, err := sdk.PrepareSendPayment(request)

if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return nil, err
}

// The response contains PayAmountDrain to indicate this is a drain operation
log.Printf("Pay amount: %v", response.PayAmount)
</code></pre>
</section>
</custom-tabs>
<h2 id="sending-payments">
    <a class="header" href="#sending-payments">Sending Payments</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.BreezSdk.html#method.send_payment">API docs</a>
</h2>
<p>Once the payment has been prepared and the fees are accepted, the payment can be sent by passing:</p>
<ul>
<li><strong>Prepare Response</strong> - The response from the <a href="send_payment.html#preparing-payments">Preparing the Payment</a> step.</li>
<li><strong>Options</strong> - Any payment method specific options for the payment (see below).</li>
<li><strong>Idempotency Key</strong> - An optional UUID that identifies the payment. If set, providing the same idempotency key for multiple requests will ensure that only one payment is made.</li>
</ul>
<h2 id="lightning-1"><a class="header" href="#lightning-1">Lightning</a></h2>
<p>In the optional send payment options for BOLT11 invoices, you can set:</p>
<ul>
<li><strong>Prefer Spark</strong> - Set the preference to use Spark to transfer the payment if the invoice contains a Spark address. By default, using Spark transfers are disabled.</li>
<li><strong>Completion Timeout</strong> - By default, this function returns immediately. You can override this behavior by specifying a completion timeout in seconds. If the timeout is reached, a pending payment object is returned. If the payment completes within the timeout, the completed payment object is returned.</li>
</ul>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">let options = Some(SendPaymentOptions::Bolt11Invoice {
    prefer_spark: false,
    completion_timeout_secs: Some(10),
});
let optional_idempotency_key = Some("&lt;idempotency key uuid&gt;".to_string());
let send_response = sdk
    .send_payment(SendPaymentRequest {
        prepare_response,
        options,
        idempotency_key: optional_idempotency_key,
    })
    .await?;
let payment = send_response.payment;
info!("Payment: {payment:?}");</code></pre>
</section>
<div slot="title">Swift</div>
<section>
<pre><code class="language-swift ignore">let options = SendPaymentOptions.bolt11Invoice(preferSpark: false, completionTimeoutSecs: 10)
let optionalIdempotencyKey = "&lt;idempotency key uuid&gt;"
let sendResponse = try await sdk.sendPayment(
    request: SendPaymentRequest(
        prepareResponse: prepareResponse,
        options: options,
        idempotencyKey: optionalIdempotencyKey
    ))
let payment = sendResponse.payment
</code></pre>
</section>
<div slot="title">Kotlin</div>
<section>
<pre><code class="language-kotlin ignore">try {
    val options = SendPaymentOptions.Bolt11Invoice(
        preferSpark = false, 
        completionTimeoutSecs = 10u
    )
    val optionalIdempotencyKey = "&lt;idempotency key uuid&gt;"
    val sendResponse = sdk.sendPayment(
        SendPaymentRequest(
            prepareResponse,
            options,
            optionalIdempotencyKey
        )
    )
    val payment = sendResponse.payment
} catch (e: Exception) {
    // handle error
}
</code></pre>
</section>
<div slot="title">C#</div>
<section>
<pre><code class="language-csharp ignore">var options = new SendPaymentOptions.Bolt11Invoice(
    preferSpark: false,
    completionTimeoutSecs: 10
);
var optionalIdempotencyKey = "&lt;idempotency key uuid&gt;";
var request = new SendPaymentRequest(
    prepareResponse: prepareResponse,
    options: options,
    idempotencyKey: optionalIdempotencyKey
);
var sendResponse = await sdk.SendPayment(request: request);
var payment = sendResponse.payment;
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript ignore">const options: SendPaymentOptions = {
  type: 'bolt11Invoice',
  preferSpark: false,
  completionTimeoutSecs: 10
}
const optionalIdempotencyKey = '&lt;idempotency key uuid&gt;'
const sendResponse = await sdk.sendPayment({
  prepareResponse,
  options,
  idempotencyKey: optionalIdempotencyKey
})
const payment = sendResponse.payment
</code></pre>
</section>
<div slot="title">React Native</div>
<section>
<pre><code class="language-typescript ignore">const options = new SendPaymentOptions.Bolt11Invoice({
  preferSpark: false,
  completionTimeoutSecs: 10
})
const optionalIdempotencyKey = '&lt;idempotency key uuid&gt;'
const sendResponse = await sdk.sendPayment({
  prepareResponse,
  options,
  idempotencyKey: optionalIdempotencyKey
})
const payment = sendResponse.payment
</code></pre>
</section>
<div slot="title">Flutter</div>
<section>
<pre><code class="language-dart ignore">final options = SendPaymentOptions.bolt11Invoice(
    preferSpark: false, completionTimeoutSecs: 10);
String? optionalIdempotencyKey = "&lt;idempotency key uuid&gt;";
final request = SendPaymentRequest(
    prepareResponse: prepareResponse,
    options: options,
    idempotencyKey: optionalIdempotencyKey);
SendPaymentResponse response = await sdk.sendPayment(request: request);
Payment payment = response.payment;
</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python ignore">try:
    options = SendPaymentOptions.BOLT11_INVOICE(
        prefer_spark=False, completion_timeout_secs=10
    )
    optional_idempotency_key = "&lt;idempotency key uuid&gt;"
    request = SendPaymentRequest(
        prepare_response=prepare_response,
        options=options,
        idempotency_key=optional_idempotency_key,
    )
    send_response = await sdk.send_payment(request=request)
    payment = send_response.payment
except Exception as error:
    logging.error(error)
    raise
</code></pre>
</section>
<div slot="title">Go</div>
<section>
<pre><code class="language-go ignore">var completionTimeoutSecs uint32 = 10
var options breez_sdk_spark.SendPaymentOptions = breez_sdk_spark.SendPaymentOptionsBolt11Invoice{
	PreferSpark:           false,
	CompletionTimeoutSecs: &amp;completionTimeoutSecs,
}

optionalIdempotencyKey := "&lt;idempotency key uuid&gt;"
request := breez_sdk_spark.SendPaymentRequest{
	PrepareResponse: prepareResponse,
	Options:         &amp;options,
	IdempotencyKey:  &amp;optionalIdempotencyKey,
}
response, err := sdk.SendPayment(request)

if err != nil {
	var sdkErr *breez_sdk_spark.SdkError
	if errors.As(err, &amp;sdkErr) {
		// Handle SdkError - can inspect specific variants if needed
		// e.g., switch on sdkErr variant for InsufficientFunds, NetworkError, etc.
	}
	return nil, err
}

payment := response.Payment
</code></pre>
</section>
</custom-tabs>
<h2 id="bitcoin-1"><a class="header" href="#bitcoin-1">Bitcoin</a></h2>
<p>In the optional send payment options for Bitcoin addresses, you can set:</p>
<ul>
<li><strong>Confirmation Speed</strong> - The priority that the Bitcoin transaction confirms, that also effects the fee paid. By default, it is set to Fast.</li>
</ul>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">// Select the confirmation speed for the on-chain transaction
let options = Some(SendPaymentOptions::BitcoinAddress {
    confirmation_speed: OnchainConfirmationSpeed::Medium,
});
let optional_idempotency_key = Some("&lt;idempotency key uuid&gt;".to_string());
let send_response = sdk
    .send_payment(SendPaymentRequest {
        prepare_response,
        options,
        idempotency_key: optional_idempotency_key,
    })
    .await?;
let payment = send_response.payment;
info!("Payment: {payment:?}");</code></pre>
</section>
<div slot="title">Swift</div>
<section>
<pre><code class="language-swift ignore">// Select the confirmation speed for the on-chain transaction
let options = SendPaymentOptions.bitcoinAddress(
    confirmationSpeed: OnchainConfirmationSpeed.medium
)
let optionalIdempotencyKey = "&lt;idempotency key uuid&gt;"
let sendResponse = try await sdk.sendPayment(
    request: SendPaymentRequest(
        prepareResponse: prepareResponse,
        options: options,
        idempotencyKey: optionalIdempotencyKey
    ))
let payment = sendResponse.payment
</code></pre>
</section>
<div slot="title">Kotlin</div>
<section>
<pre><code class="language-kotlin ignore">try {
    // Select the confirmation speed for the on-chain transaction
    val options = SendPaymentOptions.BitcoinAddress(
        confirmationSpeed = OnchainConfirmationSpeed.MEDIUM
    )
    val optionalIdempotencyKey = "&lt;idempotency key uuid&gt;"
    val sendResponse = sdk.sendPayment(
        SendPaymentRequest(
            prepareResponse,
            options,
            optionalIdempotencyKey
        )
    )
    val payment = sendResponse.payment
} catch (e: Exception) {
    // handle error
}
</code></pre>
</section>
<div slot="title">C#</div>
<section>
<pre><code class="language-csharp ignore">// Select the confirmation speed for the on-chain transaction
var options = new SendPaymentOptions.BitcoinAddress(
    confirmationSpeed: OnchainConfirmationSpeed.Medium
);
var optionalIdempotencyKey = "&lt;idempotency key uuid&gt;";
var request = new SendPaymentRequest(
    prepareResponse: prepareResponse,
    options: options,
    idempotencyKey: optionalIdempotencyKey
);
var sendResponse = await sdk.SendPayment(request: request);
var payment = sendResponse.payment;
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript ignore">// Select the confirmation speed for the on-chain transaction
const options: SendPaymentOptions = {
  type: 'bitcoinAddress',
  confirmationSpeed: 'medium'
}
const optionalIdempotencyKey = '&lt;idempotency key uuid&gt;'
const sendResponse = await sdk.sendPayment({
  prepareResponse,
  options,
  idempotencyKey: optionalIdempotencyKey
})
const payment = sendResponse.payment
</code></pre>
</section>
<div slot="title">React Native</div>
<section>
<pre><code class="language-typescript ignore">// Select the confirmation speed for the on-chain transaction
const options = new SendPaymentOptions.BitcoinAddress({
  confirmationSpeed: OnchainConfirmationSpeed.Medium
})
const optionalIdempotencyKey = '&lt;idempotency key uuid&gt;'
const sendResponse = await sdk.sendPayment({
  prepareResponse,
  options,
  idempotencyKey: optionalIdempotencyKey
})
const payment = sendResponse.payment
</code></pre>
</section>
<div slot="title">Flutter</div>
<section>
<pre><code class="language-dart ignore">// Select the confirmation speed for the on-chain transaction
final options = SendPaymentOptions.bitcoinAddress(
    confirmationSpeed: OnchainConfirmationSpeed.medium);
String? optionalIdempotencyKey = "&lt;idempotency key uuid&gt;";
final request = SendPaymentRequest(
    prepareResponse: prepareResponse,
    options: options,
    idempotencyKey: optionalIdempotencyKey);
SendPaymentResponse response = await sdk.sendPayment(request: request);
Payment payment = response.payment;
</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python ignore">try:
    # Select the confirmation speed for the on-chain transaction
    options = SendPaymentOptions.BITCOIN_ADDRESS(
        confirmation_speed=OnchainConfirmationSpeed.MEDIUM
    )
    optional_idempotency_key = "&lt;idempotency key uuid&gt;"
    request = SendPaymentRequest(
        prepare_response=prepare_response,
        options=options,
        idempotency_key=optional_idempotency_key,
    )
    send_response = await sdk.send_payment(request=request)
    payment = send_response.payment
except Exception as error:
    logging.error(error)
    raise
</code></pre>
</section>
<div slot="title">Go</div>
<section>
<pre><code class="language-go ignore">// Select the confirmation speed for the on-chain transaction
var options breez_sdk_spark.SendPaymentOptions = breez_sdk_spark.SendPaymentOptionsBitcoinAddress{
	ConfirmationSpeed: breez_sdk_spark.OnchainConfirmationSpeedMedium,
}
optionalIdempotencyKey := "&lt;idempotency key uuid&gt;"
request := breez_sdk_spark.SendPaymentRequest{
	PrepareResponse: prepareResponse,
	Options:         &amp;options,
	IdempotencyKey:  &amp;optionalIdempotencyKey,
}
response, err := sdk.SendPayment(request)

if err != nil {
	var sdkErr *breez_sdk_spark.SdkError
	if errors.As(err, &amp;sdkErr) {
		// Handle SdkError - can inspect specific variants if needed
		// e.g., switch on sdkErr variant for InsufficientFunds, NetworkError, etc.
	}
	return nil, err
}

payment := response.Payment
</code></pre>
</section>
</custom-tabs>
<h2 id="spark-1"><a class="header" href="#spark-1">Spark</a></h2>
<p>In the optional send payment options for Spark addresses, you can set:</p>
<ul>
<li><strong>HTLC Options</strong> - Enables Spark HTLC payments, which are an advanced feature that allows for conditional payments. See the <a href="htlcs.html">Spark HTLC Payments</a> page for more details and example usage.</li>
</ul>
<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>
<pre><code class="language-rust ignore">let optional_idempotency_key = Some("&lt;idempotency key uuid&gt;".to_string());
let send_response = sdk
    .send_payment(SendPaymentRequest {
        prepare_response,
        options: None,
        idempotency_key: optional_idempotency_key,
    })
    .await?;
let payment = send_response.payment;
info!("Payment: {payment:?}");</code></pre>
</section>
<div slot="title">Swift</div>
<section>
<pre><code class="language-swift ignore">let optionalIdempotencyKey = "&lt;idempotency key uuid&gt;"
let sendResponse = try await sdk.sendPayment(
    request: SendPaymentRequest(
        prepareResponse: prepareResponse,
        idempotencyKey: optionalIdempotencyKey
    ))
let payment = sendResponse.payment
</code></pre>
</section>
<div slot="title">Kotlin</div>
<section>
<pre><code class="language-kotlin ignore">try {
    val optionalIdempotencyKey = "&lt;idempotency key uuid&gt;"
    val sendResponse = sdk.sendPayment(
        SendPaymentRequest(
            prepareResponse,
            idempotencyKey = optionalIdempotencyKey
        )
    )
    val payment = sendResponse.payment
} catch (e: Exception) {
    // handle error
}
</code></pre>
</section>
<div slot="title">C#</div>
<section>
<pre><code class="language-csharp ignore">var optionalIdempotencyKey = "&lt;idempotency key uuid&gt;";
var request = new SendPaymentRequest(
    prepareResponse: prepareResponse,
    idempotencyKey: optionalIdempotencyKey
);
var sendResponse = await sdk.SendPayment(request: request);
var payment = sendResponse.payment;
</code></pre>
</section>
<div slot="title">Javascript</div>
<section>
<pre><code class="language-typescript ignore">const optionalIdempotencyKey = '&lt;idempotency key uuid&gt;'
const sendResponse = await sdk.sendPayment({
  prepareResponse,
  idempotencyKey: optionalIdempotencyKey
})
const payment = sendResponse.payment
</code></pre>
</section>
<div slot="title">React Native</div>
<section>
<pre><code class="language-typescript ignore">const optionalIdempotencyKey = '&lt;idempotency key uuid&gt;'
const sendResponse = await sdk.sendPayment({
  prepareResponse,
  options: undefined,
  idempotencyKey: optionalIdempotencyKey
})
const payment = sendResponse.payment
</code></pre>
</section>
<div slot="title">Flutter</div>
<section>
<pre><code class="language-dart ignore">String? optionalIdempotencyKey = "&lt;idempotency key uuid&gt;";
final request = SendPaymentRequest(
    prepareResponse: prepareResponse, idempotencyKey: optionalIdempotencyKey);
SendPaymentResponse response = await sdk.sendPayment(request: request);
Payment payment = response.payment;
</code></pre>
</section>
<div slot="title">Python</div>
<section>
<pre><code class="language-python ignore">try:
    optional_idempotency_key = "&lt;idempotency key uuid&gt;"
    request = SendPaymentRequest(
        prepare_response=prepare_response, idempotency_key=optional_idempotency_key
    )
    send_response = await sdk.send_payment(request=request)
    payment = send_response.payment
except Exception as error:
    logging.error(error)
    raise
</code></pre>
</section>
<div slot="title">Go</div>
<section>
<pre><code class="language-go ignore">optionalIdempotencyKey := "&lt;idempotency key uuid&gt;"
request := breez_sdk_spark.SendPaymentRequest{
	PrepareResponse: prepareResponse,
	IdempotencyKey:  &amp;optionalIdempotencyKey,
}
response, err := sdk.SendPayment(request)

if err != nil {
	var sdkErr *breez_sdk_spark.SdkError
	if errors.As(err, &amp;sdkErr) {
		// Handle SdkError - can inspect specific variants if needed
		// e.g., switch on sdkErr variant for InsufficientFunds, NetworkError, etc.
	}
	return nil, err
}

payment := response.Payment
</code></pre>
</section>
</custom-tabs>
<h2 id="event-flows"><a class="header" href="#event-flows">Event Flows</a></h2>
<p>Once a send payment is initiated, you can follow and react to the different payment events using the guide below for each payment method. See <a href="/guide/events.html">Listening to events</a> for how to subscribe to events.</p>
<div class="table-wrapper"><table><thead><tr><th>Event</th><th>Description</th><th>UX Suggestion</th></tr></thead><tbody>
<tr><td><strong>Synced</strong></td><td>The SDK has synced payments in the background.</td><td>Update the payments list and balance. See <a href="/guide/list_payments.html">listing payments</a> and <a href="/guide/get_info.html">fetching the balance</a>.</td></tr>
</tbody></table>
</div>
<h4 id="lightning-2"><a class="header" href="#lightning-2">Lightning</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Event</th><th>Description</th><th>UX Suggestion</th></tr></thead><tbody>
<tr><td><strong>PaymentPending</strong></td><td>The Spark transfer has been started. Awaiting Lightning payment completion.</td><td>Show payment as pending.</td></tr>
<tr><td><strong>PaymentSucceeded</strong></td><td>The Lightning invoice has been paid either over Lightning or via a Spark transfer</td><td>Update the balance and show payment as complete.</td></tr>
<tr><td><strong>PaymentFailed</strong></td><td>The attempt to pay the Lightning invoice failed.</td><td></td></tr>
</tbody></table>
</div>
<h4 id="bitcoin-2"><a class="header" href="#bitcoin-2">Bitcoin</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Event</th><th>Description</th><th>UX Suggestion</th></tr></thead><tbody>
<tr><td><strong>PaymentPending</strong></td><td>The Spark transfer has been started. Awaiting on-chain withdrawal completion.</td><td>Show payment as pending.</td></tr>
<tr><td><strong>PaymentSucceeded</strong></td><td>The payment amount was successfully withdrawn on-chain.</td><td>Update the balance and show payment as complete.</td></tr>
</tbody></table>
</div>
<h4 id="spark-2"><a class="header" href="#spark-2">Spark</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Event</th><th>Description</th><th>UX Suggestion</th></tr></thead><tbody>
<tr><td><strong>PaymentSucceeded</strong></td><td>The Spark transfer is complete.</td><td>Update the balance and show payment as complete.</td></tr>
</tbody></table>
</div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../guide/receive_payment.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../guide/list_payments.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../guide/receive_payment.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../guide/list_payments.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../tabs.js"></script>
        <script src="../theme/pagetoc.js"></script>



    </div>
    </body>
</html>
